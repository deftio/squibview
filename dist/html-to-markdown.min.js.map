{"version":3,"file":"html-to-markdown.min.js","sources":["../src/HtmlToMarkdown.js"],"sourcesContent":["import TurndownService from 'turndown';\n\n/**\n * Converts HTML content to Markdown format using the Turndown library with \n * customizations specific to SquibView's needs.\n */\nexport default class HtmlToMarkdown {\n  constructor(options = {}) {\n    this.turndownService = new TurndownService({\n      headingStyle: 'atx',       // Use # style headings\n      codeBlockStyle: 'fenced',  // Use ``` style code blocks\n      emDelimiter: '*',          // Use * for emphasis\n      bulletListMarker: '-',     // Use - for bullet lists\n      ...options\n    });\n    \n    // Add a simple cache for converted content to improve performance\n    this.cache = new Map();\n    this.cacheSize = options.cacheSize || 10;\n    \n    // Store special blocks for preservation\n    this._specialBlocks = new Map();\n    \n    this.configureTurndownRules();\n  }\n  \n  /**\n   * Configure custom Turndown rules\n   */\n  configureTurndownRules() {\n    // Since we're using pre-processing for data-source-type containers,\n    // we can simplify this and keep it as a fallback for any missed cases\n    this.turndownService.addRule('squibviewFencedBlock', {\n      filter: (node) => {\n        return node.nodeName === 'DIV' && node.hasAttribute('data-source-type');\n      },\n      replacement: (content, node, options) => {\n        const lang = node.getAttribute('data-source-type') || 'code';\n        let innerContent = '';\n\n        switch (lang) {\n          case 'mermaid':\n          case 'math':\n            let contentFromHtml = node.innerHTML;\n            // Convert <br> tags to newlines first\n            contentFromHtml = contentFromHtml.replace(/<br\\s*\\/?>/gi, '\\n');\n            // For Mermaid and Math, the content is expected to be text-like after <br> replacement.\n            // Avoid stripping other tags if they are part of the intended content (e.g. MathML in MathJax)\n            // Instead, rely on a robust way to get text content, then trim.\n            const tempDiv = node.ownerDocument.createElement('div');\n            tempDiv.innerHTML = contentFromHtml; // Let browser parse it\n            innerContent = tempDiv.textContent || tempDiv.innerText || ''; // Get text content\n            break;\n          case 'svg':\n            // The 'node' is the div with data-source-type=\"svg\".\n            // For proper round-trip fidelity, use the original source from the data attribute if available\n            if (node.hasAttribute('data-original-source')) {\n              // The attribute value is HTML-escaped, browser will decode it when getting the attribute\n              innerContent = node.getAttribute('data-original-source');\n            } else {\n              // Fallback to innerHTML if no original source stored\n              innerContent = node.innerHTML;\n            }\n            // console.warn('[HtmlToMarkdown] squibviewFencedBlock SVG: Captured content:', innerContent.substring(0, 200));\n            break;\n          case 'csv':\n          case 'tsv':\n          case 'psv':\n            const tableElement = node.querySelector('table');\n            if (tableElement) {\n              innerContent = this._htmlTableToDelimitedText(tableElement, lang);\n            } else {\n              innerContent = 'Error: Table not found for ' + lang;\n              console.warn('Could not find table inside div[data-source-type=\"' + lang + '\"]');\n            }\n            break;\n          default: // Handles 'javascript', 'python', 'code', etc.\n            const preElement = node.querySelector('pre');\n            if (preElement) {\n              const codeElement = preElement.querySelector('code');\n              // textContent of <code> or <pre> contains the code.\n              innerContent = (codeElement || preElement).textContent; // trimEnd removed, will be handled by trim() later\n            } else {\n              // Fallback if <pre> not found (e.g. if it was just a div with code)\n              innerContent = node.textContent; // trimEnd removed\n               console.warn('Could not find <pre> inside div[data-source-type=\"' + lang + '\"]');\n            }\n            break;\n        }\n\n        const langTag = (lang === 'code') ? '' : lang;\n        let finalInnerContent = innerContent.trim(); // Trim whitespace consistently here\n\n        if (finalInnerContent) { // If there's content after trimming\n          finalInnerContent = '\\n' + finalInnerContent + '\\n';\n        } else { // If content was empty or just whitespace\n          finalInnerContent = '\\n'; // Ensure a blank line for empty fenced blocks\n        }\n\n        return '\\n```' + langTag + finalInnerContent + '```\\n';\n      }\n    });\n\n    // Preserve HTML image tags by returning their outerHTML\n    this.turndownService.addRule('keepImageTags', {\n      filter: 'img',\n      replacement: function (content, node) {\n        return node.outerHTML;\n      }\n    });\n\n    // TEMPORARILY DISABLED: Preserve standalone <svg> tags NOT inside a data-source-type div\n    /*\n    this.turndownService.addRule('keepStandaloneSvgTags', {\n      filter: function(node) {\n        if (node.nodeName !== 'SVG') return false;\n        \n        // Don't process SVG elements that are inside a data-source-type div\n        const parentDiv = node.closest('div[data-source-type]');\n        if (parentDiv) {\n          console.warn('[HtmlToMarkdown] Skipping SVG inside data-source-type div');\n          return false;\n        }\n        \n        console.warn('[HtmlToMarkdown] Processing standalone SVG');\n        return true;\n      },\n      replacement: function (content, node) {\n        // console.warn('[HtmlToMarkdown] standalone SVG rule processing:', node.outerHTML);\n        return node.outerHTML;\n      }\n    });\n    */\n    \n    // Preserve Mermaid diagram blocks with special identifiers\n    this.turndownService.addRule('mermaid', {\n      filter: node => {\n        return node.nodeName === 'DIV' && \n               node.classList.contains('mermaid');\n      },\n      replacement: (content, node) => {\n        // Generate a unique ID for this mermaid block to help with matching later\n        const blockId = 'mermaid_' + Math.random().toString(36).substring(2, 10);\n        \n        // Store the raw content for later use\n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'mermaid',\n            content: node.textContent\n          });\n        }\n        \n        // Return with special marker that can be identified later\n        return `\\n<div data-special-block=\"${blockId}\" class=\"mermaid\">\\n` +\n               node.textContent + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    /*\n    // Preserve SVG elements with special identifiers\n    this.turndownService.addRule('svg', {\n      filter: node => {\n        // Only apply this rule if the SVG is NOT inside one of our data-source-type divs\n        // and has one of our specific identifiers (e.g., an id starting with \"squib-svg-\")\n        // or if it does not have a data-source-type attribute itself.\n        const isInsideSquibDiv = node.closest('div[data-source-type]');\n        const hasSquibIdentifier = node.id && node.id.startsWith('squib-svg-'); // Example identifier\n        const isSpecialSquibSvg = node.hasAttribute('data-source-type') && node.getAttribute('data-source-type') === 'svg';\n\n        if (isInsideSquibDiv || isSpecialSquibSvg) {\n          // console.warn('[HtmlToMarkdown] SVG rule: Skipping SVG inside data-source-type div or special SVG.');\n          return false; // Don't process if it's already handled or should be handled by squibviewFencedBlock\n        }\n        // console.warn('[HtmlToMarkdown] SVG rule: Processing standalone SVG:', node.outerHTML.substring(0,100));\n        return node.nodeName === 'SVG' && hasSquibIdentifier; // Or other conditions for standalone SVGs\n      },\n      replacement: function (content, node) {\n        // console.warn('[HtmlToMarkdown] SVG rule: Replacing with outerHTML for node:', node.outerHTML.substring(0,100));\n        return node.outerHTML; // Preserve the whole SVG tag\n      }\n    });\n    */\n\n    // Preserve GeoJSON map blocks\n    this.turndownService.addRule('geojson', {\n      filter: node => {\n        return node.nodeName === 'DIV' && \n               node.classList.contains('geojson-map');\n      },\n      replacement: (content, node) => {\n        // Generate a unique ID for this GeoJSON block\n        const blockId = 'geojson_' + Math.random().toString(36).substring(2, 10);\n        \n        // Try to extract the GeoJSON data from the script element\n        let geojsonContent = '';\n        try {\n          // The actual GeoJSON would be in a script tag or in a data attribute\n          // Here we'll use a placeholder since the actual data is hard to extract\n          geojsonContent = node.dataset.geojson || '{\"type\":\"FeatureCollection\",\"features\":[]}';\n        } catch(e) {\n          console.error('Error extracting GeoJSON data:', e);\n        }\n        \n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'geojson',\n            content: geojsonContent\n          });\n        }\n        \n        return `\\n<div data-special-block=\"${blockId}\" class=\"geojson-container\">\\n` +\n               geojsonContent + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    // Preserve Math blocks\n    this.turndownService.addRule('math', {\n      filter: node => {\n        return node.nodeName === 'DIV' && \n               node.classList.contains('math-display');\n      },\n      replacement: (content, node) => {\n        // Generate a unique ID for this math block\n        const blockId = 'math_' + Math.random().toString(36).substring(2, 10);\n        \n        // Get the raw math content (might be wrapped in $$...$$ in the original)\n        let mathContent = node.textContent;\n        \n        // Remove $$ delimiters if present\n        mathContent = mathContent.replace(/^\\$\\$([\\s\\S]*)\\$\\$$/, '$1');\n        \n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'math',\n            content: mathContent\n          });\n        }\n        \n        return `\\n<div data-special-block=\"${blockId}\" class=\"math-container\">\\n` +\n               mathContent + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    // Special handling for code blocks\n    this.turndownService.addRule('codeBlock', {\n      filter: node => {\n        return node.nodeName === 'PRE' && \n               node.firstChild && \n               node.firstChild.nodeName === 'CODE';\n      },\n      replacement: (content, node) => {\n        const code = node.firstChild.textContent;\n        let language = '';\n        \n        // Try to detect language from class\n        if (node.firstChild.className) {\n          const match = node.firstChild.className.match(/language-(\\w+)/);\n          if (match) {\n            language = match[1];\n          }\n        }\n        \n        return '\\n```' + language + '\\n' + code.trim() + '\\n```\\n';\n      }\n    });\n    \n    // Improve table handling\n    this.turndownService.addRule('tableCell', {\n      filter: ['th', 'td'],\n      replacement: (content, node) => {\n        return ' ' + content.trim() + ' |';\n      }\n    });\n    \n    this.turndownService.addRule('tableRow', {\n      filter: 'tr',\n      replacement: (content, node) => {\n        let prefix = '|';\n        \n        // Handle header rows\n        if (node.parentNode.nodeName === 'THEAD') {\n          const cells = node.querySelectorAll('th, td').length;\n          const separatorRow = '\\n|' + ' --- |'.repeat(cells);\n          return prefix + content + separatorRow;\n        }\n        \n        return prefix + content + '\\n';\n      }\n    });\n    \n    this.turndownService.addRule('table', {\n      filter: 'table',\n      replacement: (content, node) => {\n        // If this table is inside our data-source-type div, it's already handled.\n        if (node.parentElement && node.parentElement.hasAttribute('data-source-type')) {\n          const type = node.parentElement.getAttribute('data-source-type');\n          if (type === 'csv' || type === 'tsv' || type === 'psv') {\n            return content; // Turndown will process children, but our main rule handles the fence.\n          }\n        }\n        // Default table processing otherwise\n        // (Existing complex table rule logic from Turndown or custom might be here)\n        // For simplicity, using a basic version of Turndown's own table handling as a placeholder\n        // if not already handled by a more specific rule like the one above for data-source-type.\n        let markdown = '';\n        const headerRow = node.querySelector('thead tr');\n        if (headerRow) {\n          markdown += '|';\n          headerRow.querySelectorAll('th').forEach(th => {\n            markdown += ` ${this.turndownService.turndown(th.innerHTML).trim()} |`;\n          });\n          markdown += '\\n|';\n          headerRow.querySelectorAll('th').forEach(() => {\n            markdown += ' --- |';\n          });\n          markdown += '\\n';\n        }\n\n        const bodyRows = node.querySelectorAll('tbody tr');\n        bodyRows.forEach(row => {\n          markdown += '|';\n          row.querySelectorAll('td').forEach(td => {\n            markdown += ` ${this.turndownService.turndown(td.innerHTML).trim()} |`;\n          });\n          markdown += '\\n';\n        });\n        return '\\n' + markdown + '\\n';\n      }\n    });\n\n    // Ensure this class is aware of custom GFM task list items if not default in Turndown version\n    this.turndownService.keep(['li']); // Keep <li> to allow custom rule for task list items\n    this.turndownService.addRule('taskListItems', {\n      filter: function (node) {\n        return node.nodeName === 'LI' && node.firstChild && node.firstChild.nodeName === 'INPUT' && node.firstChild.type === 'checkbox';\n      },\n      replacement: function (content, node) {\n        const checkbox = node.firstChild;\n        const checked = checkbox.checked;\n        // Need to remove the input from the content that turndown processes for the <li>\n        // The first child (input) is already handled, process the rest of the <li> content.\n        // Create a temporary div to hold the rest of the li children\n        let restOfLiContent = '';\n        let current = checkbox.nextSibling;\n        while(current) {\n            restOfLiContent += current.outerHTML || current.textContent;\n            current = current.nextSibling;\n        }\n        // Turndown the rest of the LI content\n        const markdownContent = this.turndownService.turndown(restOfLiContent).trim(); \n        return (checked ? '[x] ' : '[ ] ') + markdownContent;\n      }\n    });\n  }\n  \n  /**\n   * Get a simplified hash code of a string for caching\n   * \n   * @private\n   * @param {string} str - The string to hash\n   * @returns {string} A hash representation of the string\n   */\n  _getStringHash(str) {\n    // Simple and fast hash function for strings\n    // This is not a cryptographic hash, just for caching purposes\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash.toString(36); // Convert to base36 for shorter string\n  }\n  \n  /**\n   * Convert HTML to Markdown with caching for performance\n   * \n   * @param {string} html - The HTML content to convert\n   * @param {Object} options - Additional options\n   * @param {string} options.originalSource - The original source if available\n   * @returns {string} The converted Markdown content\n   */\n  convert(html, options = {}) {\n    // Clear special blocks map for this conversion\n    this._specialBlocks.clear();\n    this._placeholders = [];\n    \n    // Use a hash of the HTML as the cache key\n    const cacheKey = this._getStringHash(html);\n    \n    // Check if we have a cached version\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n    \n    // Pre-process HTML to extract and preserve data-source-type containers\n    let processedHtml = this._preProcessSpecialContainers(html);\n    \n    // Convert the HTML to Markdown\n    let markdown = this.turndownService.turndown(processedHtml);\n    \n    // Post-process the markdown to restore special blocks\n    markdown = this._postProcessMarkdown(markdown, options.originalSource);\n    \n    // Cache the result\n    this.cache.set(cacheKey, markdown);\n    \n    // Keep the cache size under control\n    if (this.cache.size > this.cacheSize) {\n      // Remove the oldest entry\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    \n    return markdown;\n  }\n  \n  /**\n   * Pre-process HTML to extract data-source-type containers and replace them with placeholders\n   * \n   * @private\n   * @param {string} html - The HTML to process\n   * @returns {string} - The processed HTML with placeholders\n   */\n  _preProcessSpecialContainers(html) {\n    // Handle both browser and test environments safely\n    if (typeof document === 'undefined' || !document.createElement) {\n      // If no document is available, skip pre-processing and use the original HTML\n      console.warn('Document not available, skipping pre-processing');\n      this._placeholders = [];\n      return html;\n    }\n    \n    let tempDiv;\n    try {\n      tempDiv = document.createElement('div');\n      tempDiv.innerHTML = html;\n      // Test if querySelector is available - if not, we'll use a fallback approach\n      if (typeof tempDiv.querySelector !== 'function') {\n        throw new Error('querySelector not available');\n      }\n    } catch (e) {\n      // Fallback: if DOM methods aren't available, use simple regex-based processing\n      console.warn('DOM methods not available, using regex fallback for pre-processing');\n      return this._regexFallbackPreProcess(html);\n    }\n    \n    // Find all divs with data-source-type attribute\n    const specialDivs = tempDiv.querySelectorAll('div[data-source-type]');\n    const placeholders = [];\n    \n    specialDivs.forEach((div, index) => {\n      const sourceType = div.getAttribute('data-source-type');\n      const placeholder = `__SPECIAL_CONTAINER_${index}__`;\n      \n      // Store the information for later processing\n      let content;\n      if (sourceType === 'svg' && div.hasAttribute('data-original-source')) {\n        // Use the original source for perfect fidelity\n        content = div.getAttribute('data-original-source');\n      } else if (sourceType === 'csv' || sourceType === 'tsv' || sourceType === 'psv') {\n        // For delimited data, extract from the table and convert back to delimited format\n        const tableElement = div.querySelector('table');\n        if (tableElement) {\n          content = this._htmlTableToDelimitedText(tableElement, sourceType);\n        } else {\n          content = 'Error: Table not found for ' + sourceType;\n        }\n      } else {\n        // For other types (code, mermaid, etc.), extract text content from pre/code elements\n        const preElement = div.querySelector('pre');\n        if (preElement) {\n          const codeElement = preElement.querySelector('code');\n          content = (codeElement || preElement).textContent.trim();\n        } else {\n          // Fallback to text content\n          content = div.textContent.trim();\n        }\n      }\n      \n      placeholders.push({\n        placeholder,\n        type: sourceType,\n        content: content\n      });\n      \n      // Replace the div with a simple paragraph containing the placeholder\n      const placeholderElement = tempDiv.ownerDocument.createElement('p');\n      placeholderElement.textContent = placeholder;\n      div.parentNode.replaceChild(placeholderElement, div);\n    });\n    \n    // Store placeholders for post-processing\n    this._placeholders = placeholders;\n    \n    return tempDiv.innerHTML;\n  }\n\n  /**\n   * Post-process markdown to restore special blocks and apply additional formatting\n   * \n   * @private\n   * @param {string} markdown - The converted markdown \n   * @param {string} originalSource - The original markdown source if available\n   * @returns {string} - The processed markdown\n   */\n  _postProcessMarkdown(markdown, originalSource) {\n    // First pass: Replace placeholders with proper fenced code blocks\n    if (this._placeholders && this._placeholders.length > 0) {\n      this._placeholders.forEach(({ placeholder, type, content }) => {\n        const langTag = (type === 'code') ? '' : type;\n        const fencedBlock = `\\`\\`\\`${langTag}\\n${content.trim()}\\n\\`\\`\\``;\n        // The placeholder might be escaped by Markdown, so try both versions\n        const escapedPlaceholder = placeholder.replace(/_/g, '\\\\_');\n        \n        // For regex, need to escape the backslashes in the escaped placeholder\n        const regexSafeEscaped = escapedPlaceholder.replace(/\\\\/g, '\\\\\\\\');\n        markdown = markdown.replace(new RegExp(regexSafeEscaped, 'g'), fencedBlock);\n        markdown = markdown.replace(new RegExp(placeholder, 'g'), fencedBlock);\n      });\n    }\n    \n    // Second pass: Convert any remaining special blocks markers back to proper markdown\n    \n    // Convert mermaid blocks\n    const mermaidBlockRegex = /<div data-special-block=\"mermaid_[^\"]*\" class=\"mermaid\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(mermaidBlockRegex, (match, content) => {\n      return `\\n\\`\\`\\`mermaid\\n${content.trim()}\\n\\`\\`\\`\\n`;\n    });\n    \n    // Convert SVG blocks\n    const svgBlockRegex = /<div data-special-block=\"svg_[^\"]*\" class=\"svg-container\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(svgBlockRegex, (match, content) => {\n      // Try to find a closing SVG tag\n      const svgMatch = content.match(/<svg[\\s\\S]*?<\\/svg>/);\n      if (svgMatch) {\n        return `\\n\\`\\`\\`svg\\n${svgMatch[0]}\\n\\`\\`\\`\\n`;\n      }\n      return match;\n    });\n    \n    // Convert GeoJSON blocks\n    const geojsonBlockRegex = /<div data-special-block=\"geojson_[^\"]*\" class=\"geojson-container\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(geojsonBlockRegex, (match, content) => {\n      try {\n        // Ensure content is valid JSON before creating the code block\n        JSON.parse(content);\n        return `\\n\\`\\`\\`geojson\\n${content.trim()}\\n\\`\\`\\`\\n`;\n      } catch (e) {\n        console.error('Invalid GeoJSON data:', e);\n        return `\\n\\`\\`\\`geojson\\n{\"type\":\"FeatureCollection\",\"features\":[]}\\n\\`\\`\\`\\n`;\n      }\n    });\n    \n    // Convert Math blocks\n    const mathBlockRegex = /<div data-special-block=\"math_[^\"]*\" class=\"math-container\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(mathBlockRegex, (match, content) => {\n      return `\\n\\`\\`\\`math\\n${content.trim()}\\n\\`\\`\\`\\n`;\n    });\n    \n    // Second pass: Restore blocks from original source if possible\n    if (originalSource) {\n      // Extract code blocks from original source\n      const codeBlockRegex = /```(\\w+)\\s*([\\s\\S]*?)```/g;\n      let match;\n      let blockIndex = 0;\n      const originalBlocks = [];\n      \n      while ((match = codeBlockRegex.exec(originalSource)) !== null) {\n        const type = match[1];\n        const content = match[2];\n        \n        if (type === 'mermaid' || type === 'svg' || type === 'geojson' || type === 'math') {\n          originalBlocks.push({\n            type,\n            content: match[0],\n            index: blockIndex++\n          });\n        }\n      }\n      \n      // Try to match original blocks with current blocks\n      // This is a simplistic approach that assumes blocks are in the same order\n      \n      let mermaidIndex = 0;\n      let svgIndex = 0;\n      let geojsonIndex = 0;\n      let mathIndex = 0;\n      \n      // Replace mermaid blocks\n      markdown = markdown.replace(/```mermaid\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const mermaidBlocks = originalBlocks.filter(b => b.type === 'mermaid');\n        if (mermaidIndex < mermaidBlocks.length) {\n          return mermaidBlocks[mermaidIndex++].content;\n        }\n        return match;\n      });\n      \n      // Replace SVG blocks\n      markdown = markdown.replace(/```svg\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const svgBlocks = originalBlocks.filter(b => b.type === 'svg');\n        if (svgIndex < svgBlocks.length) {\n          return svgBlocks[svgIndex++].content;\n        }\n        return match;\n      });\n      \n      // Replace GeoJSON blocks\n      markdown = markdown.replace(/```geojson\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const geojsonBlocks = originalBlocks.filter(b => b.type === 'geojson');\n        if (geojsonIndex < geojsonBlocks.length) {\n          return geojsonBlocks[geojsonIndex++].content;\n        }\n        return match;\n      });\n      \n      // Replace Math blocks\n      markdown = markdown.replace(/```math\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const mathBlocks = originalBlocks.filter(b => b.type === 'math');\n        if (mathIndex < mathBlocks.length) {\n          return mathBlocks[mathIndex++].content;\n        }\n        return match;\n      });\n    }\n    \n    return markdown;\n  }\n\n  /**\n   * Converts an HTML table element to a delimited string (CSV, TSV, etc.).\n   * @param {HTMLTableElement} tableElement The HTML table element.\n   * @param {string} type The type of delimited format ('csv', 'tsv', 'psv').\n   * @returns {string} The delimited text representation of the table.\n   * @private\n   */\n  _htmlTableToDelimitedText(tableElement, type) {\n    let delimiter;\n    switch (type) {\n      case 'csv': delimiter = ','; break;\n      case 'tsv': delimiter = '\\t'; break;\n      case 'psv': delimiter = '|'; break;\n      default:    delimiter = ','; // Default to CSV\n    }\n\n    const data = [];\n    \n    // Check if we have proper DOM methods available\n    if (!tableElement || typeof tableElement.querySelectorAll !== 'function') {\n      console.warn('DOM methods not available for table extraction, using regex fallback');\n      return this._extractTableDataFromHtml(tableElement ? tableElement.outerHTML || tableElement.innerHTML || String(tableElement) : '', type);\n    }\n    \n    const rows = tableElement.querySelectorAll('tr');\n    \n    // Additional safety check for the rows result\n    if (!rows || typeof rows.forEach !== 'function') {\n      console.warn('querySelectorAll did not return proper NodeList, falling back to regex');\n      return this._extractTableDataFromHtml(tableElement.outerHTML || tableElement.innerHTML || String(tableElement), type);\n    }\n\n    rows.forEach(row => {\n      const rowData = [];\n      const cells = row.querySelectorAll('th, td');\n      cells.forEach(cell => {\n        // Basic text content extraction. For complex cell content, might need refinement.\n        // Replace newlines within a cell with a space, trim content.\n        let cellText = cell.textContent || '';\n        cellText = cellText.replace(/\\r?\\n|\\r/g, ' ').trim();\n        // If delimiter is comma, and cellText contains comma, quote it.\n        if (delimiter === ',' && cellText.includes(',')) {\n          cellText = `\"${cellText.replace(/\"/g, '\"\"')}\"`;\n        }\n        // If delimiter is tab, and cellText contains tab, it might be an issue depending on consumer.\n        // For PSV, if cellText contains pipe, it's an issue unless handled by quoting (not standard for PSV).\n        rowData.push(cellText);\n      });\n      data.push(rowData.join(delimiter));\n    });\n\n    return data.join('\\n');\n  }\n\n  /**\n   * Extract table data from HTML content using regex when DOM methods aren't available\n   * \n   * @private\n   * @param {string} htmlContent - The HTML content containing the table\n   * @param {string} type - The type of delimited format ('csv', 'tsv', 'psv')\n   * @returns {string} - The extracted delimited text\n   */\n  _extractTableDataFromHtml(htmlContent, type) {\n    let delimiter;\n    switch (type) {\n      case 'csv': delimiter = ','; break;\n      case 'tsv': delimiter = '\\t'; break;\n      case 'psv': delimiter = '|'; break;\n      default:    delimiter = ','; // Default to CSV\n    }\n\n    try {\n      // Extract all table rows using regex\n      const rowRegex = /<tr[^>]*>([\\s\\S]*?)<\\/tr>/gi;\n      const rows = [];\n      let match;\n\n      while ((match = rowRegex.exec(htmlContent)) !== null) {\n        const rowContent = match[1];\n        \n        // Extract all cells (th or td) from this row\n        const cellRegex = /<(?:th|td)[^>]*>([\\s\\S]*?)<\\/(?:th|td)>/gi;\n        const cells = [];\n        let cellMatch;\n\n        while ((cellMatch = cellRegex.exec(rowContent)) !== null) {\n          let cellText = cellMatch[1];\n          \n          // Remove HTML tags and decode entities\n          cellText = cellText\n            .replace(/<[^>]*>/g, '') // Remove all HTML tags\n            .replace(/&quot;/g, '\"')\n            .replace(/&#x27;/g, \"'\")\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&amp;/g, '&')\n            .replace(/\\r?\\n|\\r/g, ' ') // Replace newlines with spaces\n            .trim();\n\n          // Handle CSV quoting if cell contains delimiter\n          if (delimiter === ',' && cellText.includes(',')) {\n            cellText = `\"${cellText.replace(/\"/g, '\"\"')}\"`;\n          }\n\n          cells.push(cellText);\n        }\n\n        if (cells.length > 0) {\n          rows.push(cells.join(delimiter));\n        }\n      }\n\n      return rows.join('\\n');\n    } catch (e) {\n      console.error('Error extracting table data from HTML:', e);\n      return 'Error: Could not extract table data';\n    }\n  }\n\n  /**\n   * Regex-based fallback for pre-processing when DOM methods aren't available\n   * \n   * @private\n   * @param {string} html - The HTML to process\n   * @returns {string} - The processed HTML with placeholders\n   */\n  _regexFallbackPreProcess(html) {\n    // Simple regex-based approach when DOM isn't available\n    // This matches div elements with data-source-type attributes\n    const divRegex = /<div[^>]*data-source-type=\"([^\"]*)\"[^>]*>([\\s\\S]*?)<\\/div>/g;\n    const placeholders = [];\n    let index = 0;\n    \n    const processedHtml = html.replace(divRegex, (match, sourceType, content) => {\n      const placeholder = `__SPECIAL_CONTAINER_${index}__`;\n      \n      // Extract content based on type\n      let extractedContent;\n      if (sourceType === 'svg') {\n        // For SVG, look for data-original-source attribute first\n        const originalSourceMatch = match.match(/data-original-source=\"([^\"]*)\"/);\n        if (originalSourceMatch) {\n          // Decode HTML entities in the attribute value\n          extractedContent = originalSourceMatch[1]\n            .replace(/&quot;/g, '\"')\n            .replace(/&#x27;/g, \"'\")\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&amp;/g, '&');\n        } else {\n          // Fallback to inner SVG content\n          const svgMatch = content.match(/<svg[\\s\\S]*?<\\/svg>/);\n          extractedContent = svgMatch ? svgMatch[0] : content;\n        }\n      } else if (sourceType === 'csv' || sourceType === 'tsv' || sourceType === 'psv') {\n        // For delimited data, we need to extract from table using regex\n        extractedContent = this._extractTableDataFromHtml(content, sourceType);\n      } else {\n        // For code blocks, extract from pre/code elements\n        const preMatch = content.match(/<pre[^>]*><code[^>]*>([\\s\\S]*?)<\\/code><\\/pre>/);\n        if (preMatch) {\n          extractedContent = preMatch[1]\n            .replace(/<span[^>]*>/g, '')\n            .replace(/<\\/span>/g, '')\n            .replace(/&quot;/g, '\"')\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&amp;/g, '&');\n        } else {\n          // For other content types (mermaid, math, etc.), use raw content but decode HTML entities\n          extractedContent = content\n            .replace(/<[^>]*>/g, '') // Remove any HTML tags\n            .replace(/&quot;/g, '\"')\n            .replace(/&#x27;/g, \"'\")\n            .replace(/&lt;/g, '<')\n            .replace(/&gt;/g, '>')\n            .replace(/&amp;/g, '&'); // &amp; should be last to avoid double-decoding\n        }\n      }\n      \n      placeholders.push({\n        placeholder,\n        type: sourceType,\n        content: extractedContent\n      });\n      \n      index++;\n      return `<p>${placeholder}</p>`;\n    });\n    \n    // Store placeholders for post-processing\n    this._placeholders = placeholders;\n    \n    return processedHtml;\n  }\n}"],"names":["HtmlToMarkdown","_createClass","options","arguments","length","undefined","_classCallCheck","this","turndownService","TurndownService","_objectSpread","headingStyle","codeBlockStyle","emDelimiter","bulletListMarker","cache","Map","cacheSize","_specialBlocks","configureTurndownRules","key","value","_this","addRule","filter","node","nodeName","hasAttribute","replacement","content","lang","getAttribute","innerContent","contentFromHtml","innerHTML","replace","tempDiv","ownerDocument","createElement","textContent","innerText","tableElement","querySelector","_htmlTableToDelimitedText","console","warn","preElement","langTag","finalInnerContent","trim","outerHTML","classList","contains","blockId","Math","random","toString","substring","set","type","concat","geojsonContent","dataset","geojson","e","error","mathContent","firstChild","code","language","className","match","parentNode","cells","querySelectorAll","repeat","parentElement","markdown","headerRow","forEach","th","turndown","row","td","keep","checkbox","checked","restOfLiContent","current","nextSibling","str","hash","i","charCodeAt","html","clear","_placeholders","cacheKey","_getStringHash","has","get","processedHtml","_preProcessSpecialContainers","_postProcessMarkdown","originalSource","size","firstKey","keys","next","_this2","document","Error","_regexFallbackPreProcess","specialDivs","placeholders","div","index","sourceType","placeholder","push","placeholderElement","replaceChild","_ref","fencedBlock","regexSafeEscaped","RegExp","svgMatch","JSON","parse","codeBlockRegex","blockIndex","originalBlocks","exec","mermaidIndex","svgIndex","geojsonIndex","mathIndex","mermaidBlocks","b","svgBlocks","geojsonBlocks","mathBlocks","delimiter","data","_extractTableDataFromHtml","String","rows","rowData","cell","cellText","includes","join","htmlContent","rowRegex","rowContent","cellRegex","cellMatch","_this3","extractedContent","originalSourceMatch","preMatch"],"mappings":"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"}