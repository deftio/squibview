{"version":3,"file":"html-to-markdown.min.js","sources":["../src/HtmlToMarkdown.js"],"sourcesContent":["import TurndownService from 'turndown';\n\n/**\n * Converts HTML content to Markdown format using the Turndown library with \n * customizations specific to SquibView's needs.\n */\nexport default class HtmlToMarkdown {\n  constructor(options = {}) {\n    this.turndownService = new TurndownService({\n      headingStyle: 'atx',       // Use # style headings\n      codeBlockStyle: 'fenced',  // Use ``` style code blocks\n      emDelimiter: '*',          // Use * for emphasis\n      bulletListMarker: '-',     // Use - for bullet lists\n      ...options\n    });\n    \n    // Add a simple cache for converted content to improve performance\n    this.cache = new Map();\n    this.cacheSize = options.cacheSize || 10;\n    \n    // Store special blocks for preservation\n    this._specialBlocks = new Map();\n    \n    this.configureTurndownRules();\n  }\n  \n  /**\n   * Configure custom Turndown rules\n   */\n  configureTurndownRules() {\n    // Preserve Mermaid diagram blocks with special identifiers\n    this.turndownService.addRule('mermaid', {\n      filter: node => {\n        return node.nodeName === 'DIV' && \n               node.classList.contains('mermaid');\n      },\n      replacement: (content, node) => {\n        // Generate a unique ID for this mermaid block to help with matching later\n        const blockId = 'mermaid_' + Math.random().toString(36).substring(2, 10);\n        \n        // Store the raw content for later use\n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'mermaid',\n            content: node.textContent\n          });\n        }\n        \n        // Return with special marker that can be identified later\n        return `\\n<div data-special-block=\"${blockId}\" class=\"mermaid\">\\n` +\n               node.textContent + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    // Preserve SVG elements with special identifiers\n    this.turndownService.addRule('svg', {\n      filter: 'svg',\n      replacement: (content, node) => {\n        // Generate a unique ID for this SVG block\n        const blockId = 'svg_' + Math.random().toString(36).substring(2, 10);\n        \n        // Store the raw SVG for later use\n        const serializer = new XMLSerializer();\n        const svgString = serializer.serializeToString(node);\n        \n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'svg',\n            content: svgString\n          });\n        }\n        \n        // Return with special marker\n        return `\\n<div data-special-block=\"${blockId}\" class=\"svg-container\">\\n` +\n               svgString + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    // Preserve GeoJSON map blocks\n    this.turndownService.addRule('geojson', {\n      filter: node => {\n        return node.nodeName === 'DIV' && \n               node.classList.contains('geojson-map');\n      },\n      replacement: (content, node) => {\n        // Generate a unique ID for this GeoJSON block\n        const blockId = 'geojson_' + Math.random().toString(36).substring(2, 10);\n        \n        // Try to extract the GeoJSON data from the script element\n        let geojsonContent = '';\n        try {\n          // The actual GeoJSON would be in a script tag or in a data attribute\n          // Here we'll use a placeholder since the actual data is hard to extract\n          geojsonContent = node.dataset.geojson || '{\"type\":\"FeatureCollection\",\"features\":[]}';\n        } catch(e) {\n          console.error('Error extracting GeoJSON data:', e);\n        }\n        \n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'geojson',\n            content: geojsonContent\n          });\n        }\n        \n        return `\\n<div data-special-block=\"${blockId}\" class=\"geojson-container\">\\n` +\n               geojsonContent + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    // Preserve Math blocks\n    this.turndownService.addRule('math', {\n      filter: node => {\n        return node.nodeName === 'DIV' && \n               node.classList.contains('math-display');\n      },\n      replacement: (content, node) => {\n        // Generate a unique ID for this math block\n        const blockId = 'math_' + Math.random().toString(36).substring(2, 10);\n        \n        // Get the raw math content (might be wrapped in $$...$$ in the original)\n        let mathContent = node.textContent;\n        \n        // Remove $$ delimiters if present\n        mathContent = mathContent.replace(/^\\$\\$([\\s\\S]*)\\$\\$$/, '$1');\n        \n        if (this._specialBlocks) {\n          this._specialBlocks.set(blockId, {\n            type: 'math',\n            content: mathContent\n          });\n        }\n        \n        return `\\n<div data-special-block=\"${blockId}\" class=\"math-container\">\\n` +\n               mathContent + \n               `\\n</div>\\n`;\n      }\n    });\n    \n    // Special handling for code blocks\n    this.turndownService.addRule('codeBlock', {\n      filter: node => {\n        return node.nodeName === 'PRE' && \n               node.firstChild && \n               node.firstChild.nodeName === 'CODE';\n      },\n      replacement: (content, node) => {\n        const code = node.firstChild.textContent;\n        let language = '';\n        \n        // Try to detect language from class\n        if (node.firstChild.className) {\n          const match = node.firstChild.className.match(/language-(\\w+)/);\n          if (match) {\n            language = match[1];\n          }\n        }\n        \n        return '\\n```' + language + '\\n' + code.trim() + '\\n```\\n';\n      }\n    });\n    \n    // Improve table handling\n    this.turndownService.addRule('tableCell', {\n      filter: ['th', 'td'],\n      replacement: (content, node) => {\n        return ' ' + content.trim() + ' |';\n      }\n    });\n    \n    this.turndownService.addRule('tableRow', {\n      filter: 'tr',\n      replacement: (content, node) => {\n        let prefix = '|';\n        \n        // Handle header rows\n        if (node.parentNode.nodeName === 'THEAD') {\n          const cells = node.querySelectorAll('th, td').length;\n          const separatorRow = '\\n|' + ' --- |'.repeat(cells);\n          return prefix + content + separatorRow;\n        }\n        \n        return prefix + content + '\\n';\n      }\n    });\n    \n    this.turndownService.addRule('table', {\n      filter: 'table',\n      replacement: (content, node) => {\n        // If the table doesn't have a header row, we need to add the separator\n        if (!node.querySelector('thead') && node.querySelector('tr')) {\n          const firstRow = node.querySelector('tr');\n          const cells = firstRow.querySelectorAll('th, td').length;\n          const separator = '\\n|' + ' --- |'.repeat(cells) + '\\n';\n          \n          // Insert separator after the first row\n          const rows = content.split('\\n');\n          if (rows.length > 0) {\n            return rows[0] + separator + rows.slice(1).join('\\n') + '\\n\\n';\n          }\n        }\n        \n        return content + '\\n\\n';\n      }\n    });\n  }\n  \n  /**\n   * Get a simplified hash code of a string for caching\n   * \n   * @private\n   * @param {string} str - The string to hash\n   * @returns {string} A hash representation of the string\n   */\n  _getStringHash(str) {\n    // Simple and fast hash function for strings\n    // This is not a cryptographic hash, just for caching purposes\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = ((hash << 5) - hash) + char;\n      hash = hash & hash; // Convert to 32bit integer\n    }\n    return hash.toString(36); // Convert to base36 for shorter string\n  }\n  \n  /**\n   * Convert HTML to Markdown with caching for performance\n   * \n   * @param {string} html - The HTML content to convert\n   * @param {Object} options - Additional options\n   * @param {string} options.originalSource - The original source if available\n   * @returns {string} The converted Markdown content\n   */\n  convert(html, options = {}) {\n    // Clear special blocks map for this conversion\n    this._specialBlocks.clear();\n    \n    // Use a hash of the HTML as the cache key\n    const cacheKey = this._getStringHash(html);\n    \n    // Check if we have a cached version\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n    \n    // Convert the HTML to Markdown\n    let markdown = this.turndownService.turndown(html);\n    \n    // Post-process the markdown to restore special blocks\n    markdown = this._postProcessMarkdown(markdown, options.originalSource);\n    \n    // Cache the result\n    this.cache.set(cacheKey, markdown);\n    \n    // Keep the cache size under control\n    if (this.cache.size > this.cacheSize) {\n      // Remove the oldest entry\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n    \n    return markdown;\n  }\n  \n  /**\n   * Post-process markdown to restore special blocks and apply additional formatting\n   * \n   * @private\n   * @param {string} markdown - The converted markdown \n   * @param {string} originalSource - The original markdown source if available\n   * @returns {string} - The processed markdown\n   */\n  _postProcessMarkdown(markdown, originalSource) {\n    // First pass: Convert the special blocks markers back to proper markdown\n    \n    // Convert mermaid blocks\n    const mermaidBlockRegex = /<div data-special-block=\"mermaid_[^\"]*\" class=\"mermaid\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(mermaidBlockRegex, (match, content) => {\n      return `\\n\\`\\`\\`mermaid\\n${content.trim()}\\n\\`\\`\\`\\n`;\n    });\n    \n    // Convert SVG blocks\n    const svgBlockRegex = /<div data-special-block=\"svg_[^\"]*\" class=\"svg-container\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(svgBlockRegex, (match, content) => {\n      // Try to find a closing SVG tag\n      const svgMatch = content.match(/<svg[\\s\\S]*?<\\/svg>/);\n      if (svgMatch) {\n        return `\\n\\`\\`\\`svg\\n${svgMatch[0]}\\n\\`\\`\\`\\n`;\n      }\n      return match;\n    });\n    \n    // Convert GeoJSON blocks\n    const geojsonBlockRegex = /<div data-special-block=\"geojson_[^\"]*\" class=\"geojson-container\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(geojsonBlockRegex, (match, content) => {\n      try {\n        // Ensure content is valid JSON before creating the code block\n        JSON.parse(content);\n        return `\\n\\`\\`\\`geojson\\n${content.trim()}\\n\\`\\`\\`\\n`;\n      } catch (e) {\n        console.error('Invalid GeoJSON data:', e);\n        return `\\n\\`\\`\\`geojson\\n{\"type\":\"FeatureCollection\",\"features\":[]}\\n\\`\\`\\`\\n`;\n      }\n    });\n    \n    // Convert Math blocks\n    const mathBlockRegex = /<div data-special-block=\"math_[^\"]*\" class=\"math-container\">\\s*([\\s\\S]*?)\\s*<\\/div>/g;\n    markdown = markdown.replace(mathBlockRegex, (match, content) => {\n      return `\\n\\`\\`\\`math\\n${content.trim()}\\n\\`\\`\\`\\n`;\n    });\n    \n    // Second pass: Restore blocks from original source if possible\n    if (originalSource) {\n      // Extract code blocks from original source\n      const codeBlockRegex = /```(\\w+)\\s*([\\s\\S]*?)```/g;\n      let match;\n      let blockIndex = 0;\n      const originalBlocks = [];\n      \n      while ((match = codeBlockRegex.exec(originalSource)) !== null) {\n        const type = match[1];\n        const content = match[2];\n        \n        if (type === 'mermaid' || type === 'svg' || type === 'geojson' || type === 'math') {\n          originalBlocks.push({\n            type,\n            content: match[0],\n            index: blockIndex++\n          });\n        }\n      }\n      \n      // Try to match original blocks with current blocks\n      // This is a simplistic approach that assumes blocks are in the same order\n      \n      let mermaidIndex = 0;\n      let svgIndex = 0;\n      let geojsonIndex = 0;\n      let mathIndex = 0;\n      \n      // Replace mermaid blocks\n      markdown = markdown.replace(/```mermaid\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const mermaidBlocks = originalBlocks.filter(b => b.type === 'mermaid');\n        if (mermaidIndex < mermaidBlocks.length) {\n          return mermaidBlocks[mermaidIndex++].content;\n        }\n        return match;\n      });\n      \n      // Replace SVG blocks\n      markdown = markdown.replace(/```svg\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const svgBlocks = originalBlocks.filter(b => b.type === 'svg');\n        if (svgIndex < svgBlocks.length) {\n          return svgBlocks[svgIndex++].content;\n        }\n        return match;\n      });\n      \n      // Replace GeoJSON blocks\n      markdown = markdown.replace(/```geojson\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const geojsonBlocks = originalBlocks.filter(b => b.type === 'geojson');\n        if (geojsonIndex < geojsonBlocks.length) {\n          return geojsonBlocks[geojsonIndex++].content;\n        }\n        return match;\n      });\n      \n      // Replace Math blocks\n      markdown = markdown.replace(/```math\\s*([\\s\\S]*?)```/g, (match, content) => {\n        const mathBlocks = originalBlocks.filter(b => b.type === 'math');\n        if (mathIndex < mathBlocks.length) {\n          return mathBlocks[mathIndex++].content;\n        }\n        return match;\n      });\n    }\n    \n    return markdown;\n  }\n}"],"names":["HtmlToMarkdown","_createClass","options","arguments","length","undefined","_classCallCheck","this","turndownService","TurndownService","_objectSpread","headingStyle","codeBlockStyle","emDelimiter","bulletListMarker","cache","Map","cacheSize","_specialBlocks","configureTurndownRules","key","value","_this","addRule","filter","node","nodeName","classList","contains","replacement","content","blockId","Math","random","toString","substring","set","type","textContent","concat","svgString","XMLSerializer","serializeToString","geojsonContent","dataset","geojson","e","console","error","mathContent","replace","firstChild","code","language","className","match","trim","parentNode","cells","querySelectorAll","repeat","querySelector","separator","rows","split","slice","join","str","hash","i","charCodeAt","html","clear","cacheKey","_getStringHash","has","get","markdown","turndown","_postProcessMarkdown","originalSource","size","firstKey","keys","next","svgMatch","JSON","parse","codeBlockRegex","blockIndex","originalBlocks","exec","push","index","mermaidIndex","svgIndex","geojsonIndex","mathIndex","mermaidBlocks","b","svgBlocks","geojsonBlocks","mathBlocks"],"mappings":"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"}