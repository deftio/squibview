# SquibView 0.0.39 Bidirectional Rendering Improvement Plan

## Overview
This document outlines the approach for improving bidirectional rendering in SquibView, focusing on fenced code blocks, source preservation, and reliable round-trip conversions between HTML and Markdown.

## Iteration Log

This section will be updated after each development iteration to describe what was attempted and why.

**Current Focus: Achieving Clean Bidirectional Rendering for Fenced Code Blocks**

The primary goal is to ensure that Markdown fenced code blocks (e.g., ```language ... ```) are correctly converted to HTML with a `data-source-type` attribute, and that this HTML can be reliably converted back to the original Markdown. This is crucial for WYSIWYG editing of rich content.

**Debugging Journey & Observations (Leading to 0.0.39-dev.0 and ongoing):**

1.  **Initial Implementation (Markdown to HTML - Forward Rendering):**
    *   **Attempt:** Modified `squibview.js` to customize `this.md.renderer.rules.fence`. The aim was to wrap the output of fenced blocks in a `<div>` containing a `data-source-type="<language>"` attribute.
        *   Special handling was added for `mermaid`, `svg`, `geojson`, `math`, and delimiter-separated values (`csv`, `tsv`, `psv`).
        *   Mermaid and math content were HTML-escaped.
        *   SVG content was passed through directly.
        *   CSV/TSV/PSV were parsed using PapaParse and rendered as HTML tables within the `div`.
    *   **Observation:** This largely worked for the forward conversion. Tests were updated/added in `tests/SquibView.test.js` to assert the presence of `data-source-type` and correct content transformation (e.g., HTML escaping for Mermaid, table structure for CSV).
    *   **Failures/Challenges:**
        *   Minor discrepancies in test expectations for newline characters or exact HTML output from `hljs` (mocked) required adjustments.
        *   Ensuring PapaParse was correctly loaded and used for CSV/TSV/PSV blocks, both in the main code and in test mocks, was an early hurdle (`Papa is not defined` errors).

2.  **Initial Implementation (HTML to Markdown - Reverse Rendering):**
    *   **Attempt:** Added rules to `src/HtmlToMarkdown.js` (which uses Turndown.js) to handle the conversion of `div[data-source-type]` elements back to Markdown fenced blocks.
        *   A `squibviewFencedBlock` rule was created.
        *   For `mermaid` and `math`, the rule initially tried to use `node.innerHTML`, then `tempDiv.textContent` after replacing `<br>` with `\n` to extract the raw content.
        *   For `svg`, it used `node.innerHTML`.
        *   For `csv/tsv/psv`, a new utility `_htmlTableToDelimitedText` was added to parse the HTML table back into delimited text.
        *   A `keepImageTags` rule was added to prevent `<img>` tags from being converted to Markdown images, as part of a related goal.
    *   **Observation:** This phase presented more significant challenges.
    *   **Failures/Challenges:**
        *   **SVG Dropped/Empty:** The most persistent issue. The `squibviewFencedBlock` rule, and even a standalone Turndown rule for generic `<svg>` elements (re-enabled for debugging), often resulted in the SVG content being lost or converted to an empty string. `console.warn` was added to `HtmlToMarkdown.js` to trace how SVG nodes were being processed or potentially discarded by Turndown's default rules or our custom rules.
        *   **Mermaid/Math Content Extraction:** The initial method of using `innerHTML` and then `textContent` for Mermaid/Math sometimes led to issues with HTML entities or unwanted HTML structures being included. This was refined to ensure cleaner extraction of the raw code.
        *   **Test Environment:** Many tests failed due to Jest mocking complexities (`markdown-it`, global `SquibView`) and module resolution issues when unmocking. These were gradually resolved by unmocking `HtmlToMarkdown.js` for these specific tests, adjusting import paths, and refining mocks.
        *   **`<img>` Tag Preservation:** Initially, `<img>` tags were still being converted. The `keepImageTags` rule needed to be correctly positioned and prioritized in the Turndown ruleset.

3.  **Iterative Refinements & Test-Driven Debugging (Ongoing):**
    *   **Attempt (Test Corrections):** A significant number of test failures were due to incorrect expectations. For example:
        *   Mermaid newline handling in the forward rendering pass.
        *   Revision history indexing (0-indexed diffs vs. initial content as a baseline).
        *   Expected content for JS/Python blocks after `hljs` highlighting (mocked behavior).
        *   HTML entity expectations for Mermaid content in reverse rendering.
        These were adjusted in `tests/SquibView.test.js` to accurately reflect the intended behavior of the *code*.
    *   **Attempt (Code Fixes):**
        *   `squibview.js`: Imported `papaparse` directly to resolve `Papa is not defined` errors. Corrected the `onReplaceSelectedText` setter logic to properly use the event emitter.
        *   `tools/updateVersion.js`: Normalized repository URL to fix an initialization test.
    *   **Observation (Focus on SVG HTML-to-Markdown):** This remains the primary failing test for bidirectional fenced blocks. The current hypothesis is that either:
        *   Turndown's default blank replacement for unknown/unhandled complex inner HTML (like an `<svg>` element inside our `div[data-source-type="svg"]`) is taking precedence.
        *   Our `squibviewFencedBlock` rule for `div[data-source-type="svg"]` is not correctly extracting or preserving the `innerHTML` of the SVG itself.
        *   The standalone `'svg'` rule (if active) might interfere or also fail to capture the content correctly.
    *   **Next Steps for SVG:** Analyze `console.warn` output from `HtmlToMarkdown.js` (when running the specific failing test) to see what content is being passed to the rules and how Turndown processes the SVG node internally.

*   **General Summary of Approach:** The strategy has been to:
    1.  Implement the forward pass (MD -> HTML with `data-source-type`).
    2.  Implement the reverse pass (HTML with `data-source-type` -> MD).
    3.  Write comprehensive tests for both directions and for various fenced block types.
    4.  Iteratively debug by:
        *   Ensuring test expectations are correct.
        *   Fixing clear code errors (imports, logic flaws).
        *   Adding diagnostics (console logs) to trace problematic conversions (especially SVG).
        *   Adjusting Turndown rule logic and order in `HtmlToMarkdown.js`.

**Previous Iteration (Leading to 0.0.39-dev.0 - Broader Fixes):**

*   **Goal:** Address numerous test failures across initialization, Markdown rendering, revision history, CSV functionality, text selection, and fenced block processing (both forward and reverse).
*   **Approach & Rationale:**
    *   **Test Case Corrections:** Many tests failed due to incorrect expectations (e.g., Mermaid newline handling, revision history indexing, HLJS mock output). These were adjusted to match the actual, correct behavior of the code. This is a fundamental step before assuming code errors.
    *   **Code Fixes (squibview.js):**
        *   `Papa.parse` was not consistently available or correctly mocked for CSV processing. Imported `papaparse` directly into `squibview.js` and ensured tests correctly spied on `Papa.parse` where necessary. This addresses `Papa is not defined` errors.
        *   The `onReplaceSelectedText` setter was not correctly invoking the event listener due to how the handler was stored and called. Added `console.log` for diagnostics and then corrected the setter logic to ensure the event system was properly used.
    *   **Code Fixes (tools/updateVersion.js):**
        *   The repository URL in `src/version.js` was sometimes generated with `git://` instead of `https://`. Normalized the URL in `tools/updateVersion.js` to always use `https://` and remove `.git` suffix, fixing an initialization test.
    *   **Debugging (HtmlToMarkdown.js):**
        *   The SVG HTML-to-Markdown conversion was consistently failing, returning an empty string. While no direct code changes were made to `HtmlToMarkdown.js` in this iteration *for this specific issue*, previous debugging steps involved adding `console.warn` statements to trace SVG processing. The current step is to analyze these logs (once provided by the user) to pinpoint the failure.

*   **Summary:** This iteration focused on a broad set of test failures. The primary strategy was to first ensure test expectations were accurate, then address clear code errors like missing imports or incorrect event handling. For more complex issues like the SVG conversion, the focus was on gathering diagnostic information.

## Goals
1. Ensure reliable bidirectional rendering between Markdown and HTML
2. Preserve source fencing information in rendered HTML
3. Maintain existing build system integrity
4. Improve test coverage and accuracy
5. Handle image embedding with flexibility

## Non-Goals
1. Modifying the build process (ESM, UMD, standalone builds)
2. Changing existing working functionality
3. Modifying the core API surface unless absolutely necessary

## Implementation Approach

### 1. Test Suite Audit and Enhancement
- Review all existing test cases for accuracy and completeness
- Verify that test assertions match intended behavior
- Add missing test cases for edge conditions
- Ensure test coverage for all fenced block types
- Document any found discrepancies

### 2. Fenced Block Enhancement
- Implement data-source-type attributes for all fenced blocks
  - Example: ```csv → <pre data-source-type="csv">
  - Example: ```svg → <pre data-source-type="svg">
- Create mapping between fenced types and HTML attributes
- Ensure preservation of language-specific formatting
- Add validation for supported fence types

### 3. HTML to Markdown Conversion Rules
- Define clear rules for HTML → Markdown conversion
- Prioritize data-source-type attributes for fence detection
- Implement fallback rules for untagged content
- Document conversion hierarchy and decision tree

### 4. Image Handling Strategy
- Default: Preserve image src paths when possible
- Add optional API flag for data URL conversion
- Document size/performance implications
- Implement validation for supported image types

## Implementation Checklist

This checklist will guide the step-by-step execution of the plan.

### Phase 1: Test Suite Audit & Initial Enhancements (Current Phase)
- [x] Audit `tests/SquibView.test.js` to identify gaps in testing Markdown-to-HTML for fenced blocks.
- [x] Audit `tests/SquibView.test.js` to identify gaps in testing HTML-to-Markdown for fenced blocks.
- [x] Identify specific tests in `tests/SquibView.test.js` that require modification to use less intrusive mocking of `markdownit` for fenced block rendering.
- [x] Document existing custom fence rendering for `mermaid` and `svg` and how it can be adapted.

### Phase 2: Fenced Block HTML Output Enhancement (Markdown-to-HTML)
- [x] Modify `src/squibview.js`: Update the custom `markdownit` fence renderer for `mermaid` and `svg` to include `data-source-type="<type>"` attribute in their HTML output.
- [x] Update `tests/SquibView.test.js`: Modify assertions for `mermaid` and `svg` rendering tests to verify the presence of the `data-source-type` attribute.
- [x] Modify `src/squibview.js`: Extend `markdownit` fence rendering logic (or its default renderer) to add `data-source-type="<lang>"` to all other standard fenced code blocks (e.g., `javascript`, `python`, `csv`, generic `code`).
- [x] Add to `tests/SquibView.test.js`: New tests for various fenced block types (e.g., `javascript`, `python`, `csv`, `ruby`, generic code) ensuring their HTML output includes the correct `data-source-type` attribute. These tests should use a minimally mocked or real `markdownit` instance.

### Phase 3: HTML-to-Markdown Conversion for Fenced Blocks
- [x] Design and document the logic for `outputToSource` (or equivalent HTML-to-Markdown conversion method) to correctly identify HTML elements (e.g., `<pre>`) with `data-source-type` attributes.
- [x] Implement in `src/squibview.js` (via `HtmlToMarkdown.js`): The `outputToSource` logic to convert HTML elements with `data-source-type` attributes back to their corresponding Markdown fenced blocks (e.g., `<pre data-source-type="javascript">...</pre>` to ```javascript ... ```).
- [x] Add to `tests/SquibView.test.js`: New tests for HTML-to-Markdown conversion. These tests will input HTML strings containing elements with `data-source-type` attributes and verify that the output is the correct Markdown fenced block.

### Phase 4: Image Handling (as per plan)
- [x] Verify/implement default behavior: Preserve image `src` paths.
- [ ] Add optional API flag/method for data URL conversion of images.
- [x] Add tests for both image handling modes.
- [ ] Document image handling options and implications.

### Phase 5: Broader Testing & Refinement
- [ ] Conduct integration tests for complete document round-trip conversions involving various fenced blocks and mixed content.
- [ ] Perform regression testing to ensure no existing functionality is broken.
- [ ] (Optional based on findings) Explore Playwright for end-to-end browser testing of complex rendering and interaction scenarios.

### Phase 6: Documentation
- [ ] Update API documentation for any new methods or options (e.g., image data URL conversion).
- [ ] Document the `data-source-type` attribute and its usage for users or developers extending SquibView.
- [ ] Update test documentation.
- [ ] Add examples for common use cases involving new fenced block handling.

## Testing Strategy

### Phase 1: Unit Tests
1. Test individual fence type conversions
2. Verify attribute preservation
3. Test image handling in both modes
4. Validate edge cases and error conditions

### Phase 2: Integration Tests
1. Test complete document conversions
2. Verify round-trip consistency
3. Test mixed content scenarios
4. Performance benchmarking

### Phase 3: Regression Testing
1. Verify existing functionality remains intact
2. Check build output consistency
3. Validate API compatibility
4. Cross-browser testing

## Success Criteria
1. All test cases pass with clear assertions
2. Round-trip conversions preserve source formatting
3. Fenced blocks maintain type information
4. Image handling respects user preferences
5. No regression in existing functionality
6. Build process remains unchanged

## Risk Mitigation
1. Implement changes incrementally
2. Maintain comprehensive test coverage
3. Document all edge cases and decisions
4. Keep separate branches for major changes
5. Regular testing against main branch

## Timeline and Phases
1. Test Suite Audit (2-3 days)
2. Fenced Block Enhancement (3-4 days)
3. Conversion Rules Implementation (2-3 days)
4. Testing and Validation (2-3 days)
5. Documentation and Review (1-2 days)

## Documentation Requirements
1. Update API documentation
2. Document new attributes and their usage
3. Update test documentation
4. Add examples for common use cases
5. Document any breaking changes or deprecations

## Future Considerations
1. Additional fence type support
2. Performance optimizations
3. Extended image handling options
4. Enhanced debugging tools

## Development & Build Notes

### Lite Build Process
To speed up development cycles, a "lite" build process is recommended. The standard `npm run build` can be time-consuming due to standalone builds.
- **Proposed Lite Build Command**: Create a new npm script, e.g., `npm run build:lite`, that only builds the ESM and UMD modules.
  - Example `package.json` modification:
    ```json
    "scripts": {
      "build:lite": "rollup -c --environment BUILD:main && rollup -c --environment BUILD:esm",
      // ... other scripts
    }
    ```
    (Note: The exact command will depend on the current rollup configuration.)

### Browser Testing with Playwright
For comprehensive end-to-end testing that simulates real user interactions and rendering in actual browsers, consider using Playwright.
- **Integration Points**:
  - After significant features are developed (e.g., full round-trip for fenced blocks).
  - For regression testing before releases.
- **Focus Areas for Playwright**:
  - Complex rendering scenarios (e.g., nested blocks, interaction with active elements).
  - Clipboard operations.
  - Visual regression if deemed necessary. 